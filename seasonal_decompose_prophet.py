# -*- coding: utf-8 -*-
"""JustusCopy of Seasonal_Decompose.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1glg989OgWwEGkuRJEtllemQzxeB3sQ5d
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
df = pd.read_csv('https://github.com/arthursetiawan/DATA_5100_Project/blob/3ef28a95388bcf920158a93f95f13e64e68d1bfc/Fremont_Bridge_Bicycle_Counter.csv?raw=true',index_col=0)

# Remove unnecessary columns
df = df.drop(columns=['Fremont Bridge East Sidewalk','Fremont Bridge West Sidewalk'])
# Change index to DatetimeIndex
df.index=pd.to_datetime(df.index)
# Replace empty data with quadratic interpolated data
df['Fremont Bridge Total'] = df['Fremont Bridge Total'].interpolate(method='quadratic')
# Summarize data on daily, monthly, yearly bases
df_daily = df.resample('D').sum()
df_weekly = df.resample('W-MON').sum()
df_monthly = df.resample('M').sum()
df_quarterly = df.resample('Q').sum()
df_yearly = df.resample('Y').sum()

df_daily.head()

#import prophet
from prophet import Prophet
#make a copy of the df to predict
#use a function
def desireddf(df):
  df_copy = df.copy()
# set the df into required format, ds and y colums
  df_copy.reset_index(inplace=True)
  df_copy.rename(columns={"Date":"ds","Fremont Bridge Total":"y"},inplace=True)
  return df_copy

# when we want to limit predictions to just the positive values,multiplicative seasonality mode works best
m=Prophet(seasonality_mode='multiplicative').fit(desireddf(df_weekly))

# Weekly prediction
future = m.make_future_dataframe(periods=72,freq='w')
forecast = m.predict(future)

#clipper function
def clipper(df):
  for col in ['yhat', 'yhat_lower', 'yhat_upper']:
    df[col] = df[col].clip(lower=0.0)
  return df
fig = m.plot(clipper(forecast))
#fig20=m.plot(clipper(forecast)['yhat_lower']-desireddf(df_weekly)['y'])

predicted=forecast.loc[forecast['ds']>='2022-10-03 00:00:00']
previous=desireddf(df_weekly)
fig,ax= plt.subplots(1,1,figsize=(15,8)) 
plt.figure(figsize=(15,4))
#fig20=m.plot(desireddf(df_weekly)['y']-clipper(forecast)['yhat'])
graph2=ax.plot(previous.ds,previous.y,label="Actual")
graph3= ax.plot(predicted.ds,predicted.yhat,label="Predicted")
ax.axhline(predicted.yhat.max(),color="red")
ax.axhline(predicted.yhat.min(),color="red")
ax.legend(loc='upper right')
plt.show()

#residual
import seaborn as sns
combined=pd.merge( desireddf(df_weekly),forecast, on=['ds'],
                           how='inner')
combined["residual"]=desireddf(df_weekly)['y']-forecast.yhat
#plot the figure
fig,ax= plt.subplots(2,1,figsize=(15,8)) 
plt.figure(figsize=(15,4))
graph=ax[0].plot(combined.ds,combined.residual,marker="o", linestyle="none")
#fig20=m.plot(desireddf(df_weekly)['y']-clipper(forecast)['yhat'])
graph2=ax[1].plot(combined.ds,combined.y,label="Actual")
graph3= ax[1].plot(combined.ds,combined.yhat,label="Predicted")
ax[1].legend(loc='upper right')
ax[0].axhline(0,color="black")
plt.show()
#combined.head()
#desireddf(df_weekly)['residual'].head()

# Python
lockdowns = pd.DataFrame([
    {'holiday': 'lockdown_1', 'ds': '2020-03-21', 'lower_window': 0, 'ds_upper': '2020-06-06'},
    {'holiday': 'lockdown_2', 'ds': '2020-07-09', 'lower_window': 0, 'ds_upper': '2020-10-27'},
    {'holiday': 'lockdown_3', 'ds': '2021-02-13', 'lower_window': 0, 'ds_upper': '2021-02-17'},
    {'holiday': 'lockdown_4', 'ds': '2021-05-28', 'lower_window': 0, 'ds_upper': '2021-06-10'},
])
for t_col in ['ds', 'ds_upper']:
    lockdowns[t_col] = pd.to_datetime(lockdowns[t_col])
lockdowns['upper_window'] = (lockdowns['ds_upper'] - lockdowns['ds']).dt.days
lockdowns

#covid and without covid seasonalities
# Python
df=desireddf(df_weekly)
df2 = df.copy()
df2['pre_covid'] = pd.to_datetime(df2['ds']) < pd.to_datetime('2020-03-21')
df2['post_covid'] = ~df2['pre_covid']

m2 = Prophet(holidays=lockdowns,seasonality_mode='multiplicative', weekly_seasonality=False,interval_width=0.95)
m2.add_seasonality(
    name='weekly_pre_covid',
    period=7,
    fourier_order=3,
    condition_name='pre_covid',
)
m2.add_seasonality(
    name='weekly_post_covid',
    period=7,
    fourier_order=3,
    condition_name='post_covid',
);

m2.fit(df2)
future4 = m2.make_future_dataframe(periods=72,freq='w')
future4['pre_covid'] = pd.to_datetime(future4['ds']) < pd.to_datetime('2020-03-21')
future4['post_covid'] = ~future4['pre_covid']

desireddf(df_weekly)['ds'].max()

forecast4 = m2.predict(future4)
forecast4=clipper(forecast4)
m2.plot(forecast4.loc[forecast4['ds']>'2022-10-03 00:00:00'])
plt.title('Lockdowns as one-off holidays + Conditional weekly seasonality');

predicted=forecast4.loc[forecast4['ds']>='2022-10-03 00:00:00']
previous=desireddf(df_weekly)
fig,ax= plt.subplots(1,1,figsize=(15,8)) 
plt.figure(figsize=(15,4))
#fig20=m.plot(desireddf(df_weekly)['y']-clipper(forecast)['yhat'])
graph2=ax.plot(previous.ds,previous.y,label="Actual")
graph3= ax.plot(predicted.ds,predicted.yhat,label="Predicted")
ax.axhline(predicted.yhat.max(),color="red")
ax.axhline(predicted.yhat.min(),color="red")
ax.legend(loc='upper right')
plt.show()

forecast4.head()

combined_covid=pd.merge( desireddf(df_weekly),forecast4, on=['ds'],
                           how='inner')
combined_covid["residual"]=desireddf(df_weekly)['y']-forecast4.yhat
#plot the figure
fig,ax= plt.subplots(2,1,figsize=(15,8)) 
#plt.figure(figsize=(15,4))
graph=ax[0].plot(combined_covid.ds,combined_covid.residual,marker="o", linestyle="none")
#fig20=m.plot(desireddf(df_weekly)['y']-clipper(forecast)['yhat'])
graph2=ax[1].plot(combined_covid.ds,combined_covid.y,label="Actual")
graph3= ax[1].plot(combined.ds,combined_covid.yhat,label="Predicted")
ax[1].legend(loc='upper right')
ax[0].axhline(0,color="black")
plt.show()
#combined.head()
#desireddf(df_weekly)['residual'].head()

#comparative residuals for before and after covid at 95% CI
#plot the figure

import seaborn as sns
import statsmodels.api as sm
import scipy.stats as stats
##Comparative
fig,ax= plt.subplots(2,1,figsize=(15,8)) 
graph=ax[0].plot(combined.ds,combined.residual,marker="o", linestyle="none",label="No_covid")
graph=ax[0].plot(combined_covid.ds,combined_covid.residual,marker="o", linestyle="none",label="covid_factor")
#fig20=m.plot(desireddf(df_weekly)['y']-clipper(forecast)['yhat'])
ax[0].legend(loc='best')
ax[0].axhline(0,color="black")
##qqplot
stats.probplot(combined.residual, plot=ax[1], fit=False);
stats.probplot(combined_covid.residual, plot=ax[1], fit=False);

ax[1].get_lines()[0].set_markerfacecolor('#0000EE')
ax[1].get_lines()[1].set_markerfacecolor('#FF8C00')


ax[1].get_lines()[0].set_markeredgewidth(0)
ax[1].get_lines()[1].set_markeredgewidth(0)


plt.legend(title='Covid', loc='upper left', labels=['No_covid','Covid'])
plt.show()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats

sns.set_style("whitegrid")

fig, ax = plt.subplots(1,1, figsize=(12,8))
stats.probplot(combined.residual, plot=ax, fit=False);
stats.probplot(combined_covid.residual, plot=ax, fit=False);

ax.get_lines()[0].set_markerfacecolor('c')
ax.get_lines()[1].set_markerfacecolor('m')


ax.get_lines()[0].set_markeredgewidth(0)
ax.get_lines()[1].set_markeredgewidth(0)


plt.legend(title='Covid', loc='upper left', labels=['No_covid','Covid'])
plt.show()

#References
#Facebook Prophet: https://facebook.github.io/Prophet/ 
